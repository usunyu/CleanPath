package adj_lists;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

	/**
	 *
	 * @author Ugur
	 *
	 * Perfoms the data analysis. Data is generated by DataListGenerator.java and DataStaticGenerator.java
	 * it also finds the no of distinct paths according to the similarity tolerance as follows:
	 * 		First from the pairs of dirPaths, it loads all paths for each pair (each .txt file).
	 * 		it finds the representative path, the one which has the biggest number of occurances per day.
	 * 		Then, according to the tolerance factor, if the rest of the paths are similar to the repre-
	 * 		sentative one, then they are not counted. They are added to the hash tables in the place of
	 * 		the critical ponts (although obviously they are not critical points they are just new counting)
	 *
	 *
	 *
	 */


public class Analysis {

	static Map<Integer, Integer> Paths = new HashMap<Integer, Integer>();
	static Map<Integer, Integer> CP = new HashMap<Integer, Integer>();
	public static File dir = new File("stats2smoothed3/");
	public static File dirPaths = new File("pairs2/");
	public static int tolerance = 100; 								// counts the percentage of similarity between different paths and the representative path
																	// values in experiments:80, 95, 100 (code check)

	private static void addToCounting(int noPaths, int noCP){		// it counts the number of pairs that have the same number of distinct optimal paths
																	// and CPs


		if (!Paths.containsKey(noPaths)){
			Paths.put(noPaths, 1);
		}
		else {
			Paths.put(noPaths, Paths.get(noPaths)+1);

		}

		if (!CP.containsKey(noCP)){
			CP.put(noCP, 1);
		}
		else {
			CP.put(noCP, CP.get(noCP)+1);

		}

	}

	private static void addToHashForPathOverlap(int noPaths, int avg){			//this weird think is used to count the average path similarity to a representative path
																				//per no of distinct paths
		if (!Paths.containsKey(noPaths)){
			Paths.put(noPaths, 1);
			CP.put(noPaths, avg);
		}
		else {
			CP.put(noPaths,(CP.get(noPaths)*Paths.get(noPaths)+avg)/(Paths.get(noPaths)+1));
			Paths.put(noPaths, Paths.get(noPaths)+1);

		}
	}

	private static void addToCounting2 (int noPaths, int noCP) {	// It is used to produce the curve of noPaths w.r.t. noCP

		if (!Paths.containsKey(noPaths)){
			Paths.put(noPaths, noCP);
		}
		else {
			Paths.put(noPaths, Paths.get(noPaths)+noCP);
//		if (noCP<Paths.get(noPaths))
//				Paths.put(noPaths, noCP);
//


		}
	}

	private static void firstStats(){		// Reads all stats files generated before.

		String inFile = "";
		String temp="";
		String noOfPaths="";
		String noOfCP="";
		File[] files = dir.listFiles();
		int max=0;

		for (File f: files){
			inFile=f.toString();

//			System.out.println(inFile);
			try {
		            RandomAccessFile file = new RandomAccessFile(inFile, "rw");

		            while ((temp=file.readLine())!=null ) {

			            noOfPaths=temp.substring(temp.indexOf(':')+1, temp.indexOf(','));

			            noOfCP=temp.substring(temp.indexOf(',')+1, temp.indexOf(' '));

			            if (max<Integer.parseInt(noOfCP)) max=Integer.parseInt(noOfCP);
			            if (Integer.parseInt(noOfCP)==56) System.out.println(inFile);

//			            if (noOfPaths.equals("2") && Integer.parseInt(noOfCP)==9)
//			            	System.out.println(i+"->"+temp);
			            addToCounting(Integer.valueOf(noOfPaths),Integer.valueOf(noOfCP));

		            }

		            file.close();

			 }
			 catch (IOException io) {
		            System.err.println(io.toString());
		            System.exit(1);
		     }
		}
//		printStats();
		System.out.print(max);

	}

	private static void printStats(){
		for (int key: Paths.keySet()){
	    	System.out.println(key+","+Paths.get(key));

	    }
		System.out.println("--------------");
		for (int key: CP.keySet()){
	    	System.out.println(key+","+CP.get(key));

	    }
	}

	private static void pathOverlap() {
		String inFile = "";
		String temp="";

		File[] files = dirPaths.listFiles();

		for (File f: files){
			inFile=f.toString();
			System.out.println(inFile);

            boolean priliminary=true;


			try {
		            RandomAccessFile file = new RandomAccessFile(inFile, "r");

		            int pathID=0;			// will store the ID of the most frequent path
	            	int maxCounter=0;		// will be used to count the no of occurances of each path
	            	int i=0,j=0;			// j will contain the total number of paths (before grouping them)
	            	LinkedList<String> paths = new LinkedList<String>();

		            while (	(temp=file.readLine()) != null ) {
		            	if(priliminary && !temp.equals("")){			//reading the path list
		            		paths.offer(temp);
		            		continue;
		            	}
		            	else if (temp.equals("")){						// out of path list
		            		priliminary=false;
		            		continue;
		            	}

		            	String currPath=temp;

		            	while ((temp=file.readLine())!=null && !temp.equals(""))
		            		i++;
		            	if (i>maxCounter){
		            		maxCounter=i;
		            		pathID=j;
		            	}
		            	i=0;
		            	j++;

		            }

		            file.close();
		            String pathRepresentative=paths.get(pathID);
		            int average=0;
		            int newNoOfPaths=j;
		            for (i=0;i<j;i++){
		            	if (i!=pathID){
//		            		if (DataStaticGenerator.computeOverlap(pathRepresentative,paths.get(i))>tolerance)
//		            			newNoOfPaths--;
		            		average+= DataStaticGenerator.computeOverlap(pathRepresentative,paths.get(i));
		            	}
		            }
		            if (j>1)
		            	average/=j-1;
		            else
		            	average=100;
//		            addToCounting(j,newNoOfPaths);
		            addToHashForPathOverlap(j,average);


			 }
			 catch (IOException io) {
		            System.err.println(io.toString());
		            System.exit(1);
		     }
		}

		printStats();

	}


	public static void main(String[] args) {

		//firstStats();
//		pathOverlap();
		String dir_path = "stats_saved\\stats_q_";

		for (int group = 0; group < 10; group++){
			String filename = dir_path + group + "\\stats_q_" + group + ".txt";
			try {
				System.out.println(filename);
	            RandomAccessFile file = new RandomAccessFile(filename, "rw");
	            String temp;
	            String noOfPaths="";
	    		String noOfCP="";
	    		int line = 0;
	    		int totalPaths = 0;
	    		int totalCPs = 0;
	            while ((temp=file.readLine())!=null ) {
	                noOfPaths=temp.substring(temp.indexOf(':')+1, temp.indexOf(','));
		            noOfCP=temp.substring(temp.indexOf(',')+1, temp.indexOf(' '));

		            totalPaths += Integer.parseInt(noOfPaths);
		            totalCPs += Integer.parseInt(noOfCP);

		            line++;
	            }
	         	System.out.println(totalPaths/line);
	         	System.out.println(totalCPs/line);
	            file.close();
			}
			catch (IOException io){
				System.err.println(io.toString());
	            System.exit(1);
			}
		}

	}


}
