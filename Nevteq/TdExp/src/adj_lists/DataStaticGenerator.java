package adj_lists;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;
import java.util.Vector;

import adj_lists.DataListGeneration.Node;

public class DataStaticGenerator {
	
	/**
	 * @author Panos
	 * 
	 * Loads the graph into main memory by reading the file StaticData.txt generated by BuildStaticData.java.
	 * To do that it calls BuildList with the overloaded constructor.
	 * 
	 * Generates the file "output.txt" that contains statistical comparison of the TDSP path selection and the
	 * static path selection. The output contains:
	 * 
	 * Source	Target	Counter	 accuracy_average(%)	 maxloss(sec) 	 max_overhead(%)
	 * 
	 * 								|-> it refers to the average overhead introduced by the static path (absolute_value of time differencies)
	 * 
	 * 
	 */
	
	public static class Edge {					// Class Edge.
		
		private int startNode;
		private int endNode;
		
		public Edge(int start, int end) {
			startNode = start;
			endNode = end;
			
		}
		public int getStartNode() {
			return startNode;
		}
		public int getEndNode() {
			return endNode;
		}
		
		public boolean compare(Edge e){
			return ((startNode==e.getStartNode()) && (endNode==e.getEndNode()));
		}
			
	}
	
	public static BuildList staticGraph = new BuildList("GoogleData_Monday.txt");
	
	//Dynamic Graph, used for generate the travel time for static time begin with certain time
	public static BuildList graph = new BuildList();
	
	public static int compute (LinkedList<Integer> list, int time) {		//Given a path (as a list of nodes) and a departure time,
		//compute the travel time.
		int path_time=0;
		int when=time;
		int i,j;
		int times=graph.getTimes();
		LinkedList<Integer> path= new LinkedList<Integer> ();
		path=(LinkedList<Integer>) list.clone();
		
		int timeInterval = 15;
		while (!path.isEmpty()){
			List<adj_lists.Pair<Integer, int[]>> neighbors;
			when=time+path_time/60/1000/timeInterval;
			
			if (when>times-1){
				when=times-1;
			}
			i=path.poll();
			if ((path.peek()) !=null) {
				j=path.peek();
				neighbors=graph.getList().get(i);
				if (neighbors==null)
					continue;
				for(Pair<Integer, int[]> pair: neighbors) {
					if (pair.getLeft()==j){
						path_time+=pair.getRight()[when];
						break;
					}
				}
			}	
		}
		return path_time;
	}

	public static int computePath(String path, int startTime){
			LinkedList<Integer> Path=stringToList(path);
			return compute(Path, startTime);
	}
	
	
	
	public static String dirPath="queryresult//monday//onepercentsmoothed//";
	public static int tolerance=100;		//percentage of similarity allowed between static path and actual path, to be considered correct
	
	//compute dynamic path
	static int timeInterval=15;
	static int Lsp = 0;
	static int times;
	
	
	public static class Node {					// Class Node. Cost and ArrTime are used interchangably, I kept them for compitability with Ugur's code
		// dist is of no use.
public Node(int id, int c, int t) {
nodeId = id;
cost = c;
arrTime = t;
dist = new Vector(10, 5);
}
public int getNodeId() {
return nodeId;
}
public int getNodeCost() {
return cost;
}
public int getArrTime() {
return arrTime;
}
public void setArrTime(int t) {
arrTime = t;
}
public void setCost(int t) {
cost = t;
}

private int nodeId, cost, arrTime;
private Vector dist; // denoted by 'c' in the algorithm

}
	
	static Queue<Integer> path;
	
	/*
	 * The difference between my function with tdsp is that I used an array visited[] to
	 * indicate whether a node has been visited before so that we do not need to scan the 
	 * priority queue before updating it 
	 * commented by Dingxiong
	 */
	private static void tdsp_2(int start, int end, int time) {	
	       	   PriorityQueue<Node> priorityQ = new PriorityQueue<Node>(20,
	               new Comparator<Node>() {
	                   public int compare(Node n1, Node n2) {
	                       return n1.cost - n2.cost;
	                   }
	               }
	           );

	           int startTime=time;								// stores the trip initialization time

	           int nn= graph.getSize();
	           int i, len = nn, arrTime, w, j, id;
	           int[] c = new int[len];
	           int[] parent = new int[len];
	           boolean unreachable=false;
	           /*
	            * add visited vector
	            * commented by Dingxiong
	            */
	           boolean[] visited = new boolean[len];
	           for(i=0; i<len; i++) {
	                   visited[i] = false;                      		//indicating infinity
	           }
	                              
	                  		
	           for(i=0; i<len; i++)
	               parent[i] = -1;

	           Iterator<Node> it;
	           boolean qFlag = false;

	           for(i=0; i<len; i++) {
	               if(i == start)
	                   c[i] = 0;                       					//starting node
	               else
	                   c[i] = Integer.MAX_VALUE;                      		//indicating infinity
	           }
	           	           
	          // try{
		      //    FileWriter fstream = new FileWriter("pairs2\\qu2.txt");
		      //    BufferedWriter out = new BufferedWriter(fstream);
	           
	           
	           Node tempN, n, s = new Node(start, 0, startTime);       	//creating the starting node with nodeId = start and cost = 0 and arrival time = time
	           priorityQ.offer(s);                     					//inserting s into the priority queue
	           int count=0;
	           while ((n = priorityQ.poll()) != null) { 					//while Q is not empty
	           	List<adj_lists.Pair<Integer, int[]>> neighbors;

	           	time= startTime+n.getArrTime()/60/1000/timeInterval; 			//define time interval at the beginning (granularity)
//	           	time=startTime;
//	           	count++;
	           	if (time>times-1){												// time [6am - 9 pm], we regard times after 8PM as constant edge weights 
	           		time=times-1;
	           	}
	               id = n.getNodeId();
	               /*
	                * using visited vector
	                */
	               if (visited[id] == true)
	            	   continue;
	               visited[id] = true;  
	               
//	               System.out.println(count+"");
	               neighbors=(List<Pair<Integer, int[]>>) graph.getList().get(id);
	               arrTime = n.getArrTime();

	               if (neighbors==null)
	           		continue;
	               for(Pair<Integer, int[]> pair: neighbors) {
	            	   	
	               	int node=pair.getLeft();
	               	int travelTime=pair.getRight()[time];
	               	/*
	               	 * if the node is visited, we bypass it
	               	 * commented by Dingxiong
	               	 */
	               	if (visited[node] == true) continue;
	               	// if we find a node with updated distance, just insert it to the priority queue
	               	// even we pop out another node with same id later, we know that it was visited and will ignore it
	               	//commented by Dingxiong
	               	if (arrTime + travelTime < c[node]) {
	               		c[node] = arrTime + travelTime;
	               		parent[node] = id;
	               		priorityQ.offer(new Node(node, c[node], c[node]));       		                		
	               	  }
	                }
	               	
	           }

	          // System.out.println("Find the path");
	           
	          //find the path
	           int temp;
	           int[] nextNode = new int[len];
	           for(i=0; i<len; i++)
	               nextNode[i] = -1;

	           temp = end;
	           while(temp != -1) {
	               if(parent[temp] != -1)
	                   nextNode[parent[temp]] = temp;
	               temp = parent[temp];
	           }


	           if (start == end)
	               System.out.println("Your starting node is the same as your ending node.");
	           else {
	               i = start;
	               j = 1;
//	               System.out.print(i);
	               path.offer(i);
	               while (i != end) {
	               	if (nextNode[i]==-1){
	               		unreachable=true;
	               		break;
	               	}
	               	path.offer(nextNode[i]);
//	                   System.out.print(" " + nextNode[i]);
	                   i = nextNode[i];
	               }
	               if (!unreachable){

	   	            path.offer((c[end]-startTime));
//	   	            System.out.println(" "+c[end]);
	   	            if(c[end] > Lsp) {
	   	                Lsp = c[end];
	   	            }
	               }
	               else {
	               	path.offer(end);
	               	path.offer(-1);

	               }
	           }
	}
	
	//finish computing dynamic path
	
	public static Pair<String,Integer> computeStaticPath(int start, int end){

	        PriorityQueue<Node> priorityQ = new PriorityQueue<Node>(20,
	            new Comparator<Node>() {
	                public int compare(Node n1, Node n2) {
	                    return n1.getNodeCost() - n2.getNodeCost();
	                }
	            }
	        );
	        
	        
	        int nn= staticGraph.getStaticSize();
	        int i, len = nn, arrTime, w, j, id;
	        int[] c = new int[len];
	        int[] parent = new int[len];
	        boolean unreachable=false;
	        
	        
	        for(i=0; i<len; i++)
	            parent[i] = -1;

	        Iterator<Node> it;
	        boolean qFlag = false;

	        for(i=0; i<len; i++) {
	            if(i == start)
	                c[i] = 0;                       					//starting node
	            else
	                c[i] = Integer.MAX_VALUE;                      		//indicating infinity
	        }	

	        Node tempN, n, s = new Node(start, 0, 0);       			//creating the starting node with nodeId = start and cost = 0 and arrival time = time
	        priorityQ.offer(s);                     					//inserting s into the priority queue
	        int count=0;
	        while ((n = priorityQ.poll()) != null) { 					//while Q is not empty
	        	List<adj_lists.Pair<Integer, Integer>> neighbors;
	        	
	        	id = n.getNodeId();
	            if (id==end){ 
	            	//System.out.println("found nodes");
	            	break;
	            }
	        	count++;
//	            System.out.println(count+"");
	            neighbors=(List<Pair<Integer, Integer>>) staticGraph.getStaticList().get(id);
	            arrTime = n.getArrTime();
	            
	            if (neighbors==null)
	        		continue;
	            for(Pair<Integer, Integer> pair: neighbors) {
	          
	            	int node=pair.getLeft();
	            	int travelTime=pair.getRight();
	            	
	            	 if (arrTime + travelTime < c[node]) {
	            		 c[node] = arrTime + travelTime;
	                     parent[node] = id;
	                     it = priorityQ.iterator();
	                     while (it.hasNext() == true) {
	                         if ( (tempN = it.next()).getNodeId() == node) {
	                             if(priorityQ.remove(tempN) == true) {
	                                 tempN.setArrTime(c[node]);
	                                 priorityQ.offer(tempN);
	                                 qFlag = true;
	                             }
	                             break;
	                         }
	                     }
	                     
	                     if(qFlag == false) {
	                         priorityQ.offer(new Node(node, c[node], c[node])); //arrival time = c[i]
	                    //     System.out.println("inserting " + i);
	                     }
	                     else
	                         qFlag = false;
	            		 
	            	 }
	            }
	        }
	        //return count;
	        int temp;
	        int[] nextNode = new int[len];
	        for(i=0; i<len; i++)
	            nextNode[i] = -1;

	        temp = end;
	        while(temp != -1) {
	            if(parent[temp] != -1)
	                nextNode[parent[temp]] = temp;
	            temp = parent[temp];
	        }
	        
	        String path="";
	        if (start == end)
	            System.out.println("Your starting node is the same as your ending node.");
	        else {
	            i = start;
	            j = 1;
//	            System.out.print(i);
	            path=start+" ";
	            while (i != end) {
	            	if (nextNode[i]==-1){
	            		unreachable=true;
	            		break;
	            	}
	            	path+=nextNode[i]+" ";
//	                System.out.print(" " + nextNode[i]);
	                i = nextNode[i];
	            }
	           
	            
	        }
	        path+=" ";
	        Pair<String,Integer> pair = new Pair<String, Integer>(path,c[end]);
	        return pair;
	}
	
	public static void compare(int source, int target, int group){
		Pair<String,Integer> pair=computeStaticPath(source, target);
//		System.out.print(pair.getLeft().toString()+" "+pair.getRight().toString()+"\n");
		
		String inFile = dirPath + "\\smoothed_q_" + group + "\\"+source+"-"+target+".txt";
		FileOutputStream out=null;
		
		
		
        try {      	
        	String outdir = dirPath + "\\wholeresult\\googletime\\timediff\\";
        	String name = outdir + "smooth_ana_q_" + (group+1) + ".txt";
        	File f = new File(name);
        	//out = new FileOutputStream(new File(outdir + "ana_q_0.txt"), true);
        	
        	if (!f.exists()) {
    			try {
    				out = new FileOutputStream(name, false);
//    				System.out.println("---------------------"+source+"-------------------");

    			}
    			catch (IOException e1) {
    				// TODO Auto-generated catch block
    				e1.printStackTrace();
    			}
    		}
    		else {
    			try {
    				out = new FileOutputStream(name, true);
    			} catch (FileNotFoundException e) {
    				// TODO Auto-generated catch block
    				e.printStackTrace();
    			}
    		}    	
        	
            RandomAccessFile file = new RandomAccessFile(inFile, "rw");
            String temp="";
            boolean rightPath=false;
            boolean priliminary=true;
            int counter=0;
            
            //int staticTime=pair.getRight();
            String staticPath= pair.getLeft();
           
            int accuracy=0;
            int maxloss=0;
            int pathOverlap=0, i=0;
            
            //defined by dingxiong
            int aveloss = 0;
            int minloss = Integer.MAX_VALUE;
            float aveoverlap;
            int minoverlap = Integer.MAX_VALUE;
            int maxoverlap = 0;
            int overlapdiff = 0;
            int totalAccuray = 0;
            
            int acturaldiff, acturalMinloss, acturalMaxloss, acturalAveloss;
            acturalMinloss = Integer.MAX_VALUE;
            acturalMaxloss = 0;
            acturalAveloss = 0;
            
            int countAve = 0, countAct = 0;
            
            while (	(temp=file.readLine()) != null ) {
            	if(priliminary && !temp.equals("")){			//reading the path list
            		continue;
            	}
            	else if (temp.equals("")){						// out of path list
            		priliminary=false;
            		continue;
            	}
            	if (temp.startsWith(staticPath)){	// check if the path is the one found by the static computation
            		rightPath=true;
            	}
            	String currPath=temp;
            	//System.out.println(currPath);
            	pathOverlap=computeOverlap(currPath,staticPath);
            	int time,diff,timeStamp;
            	double diffPercent;
            	int acturalDiff;
            	double acturalDiffpercent;
            	
            	while ((temp=file.readLine())!=null && !temp.equals("")){
            		//System.out.println(temp);
            		timeStamp=Integer.parseInt(temp.substring(temp.indexOf('[')+1,temp.indexOf(',')));	// check the accuracy for a specific time range
            		int acturalTime = computePath(staticPath, timeStamp);
            		int staticTime=pair.getRight();
            		//System.out.println("timeStamp: " +timeStamp + " StaticTime: " + staticTime + " ActuralTime: " + acturalTime + " Optimal Time:" );
            		if ((timeStamp>3 && timeStamp<19)){ //|| (timeStamp>39 && timeStamp<55)) {	// this corresponds to times from 7AM-10:30AM and 4PM-7:30PM
            			i++;
            			time=Integer.parseInt(temp.substring(temp.indexOf(',')+1,temp.indexOf(']')));
            			//System.out.println("timeStamp: " +timeStamp + " StaticTime: " + staticTime + " ActuralTime: " + acturalTime + " Optimal Time: " + time+ " Diff: " + (acturalTime - time)/60000);
            			diff=(staticTime-time);	
            			acturalDiff = acturalTime - time;
	            		if (rightPath != true){
	            			diffPercent = Math.abs(diff) / 60000.0;
	            			diffPercent = Math.abs(diff) * 100 /staticTime;
	            			//System.out.println("timeStamp: " +timeStamp + " StaticTime: " + staticTime + " Diffpercent: " + diffPercent);
	            			if (diff > 0 ){
	            				if (diffPercent > maxloss)
	            					maxloss= (int)diffPercent;
	            				if (diffPercent < minloss)
	            					minloss = (int)diffPercent;
	            				aveloss += diffPercent;
	            				countAve++;
	            			}
	            			
	            			//calculate percentage
	            			//acturalDiffpercent = Math.abs(acturalDiff) * 100 / acturalTime;
	            			
	            			//calculate different time
	            			acturalDiffpercent = Math.abs(acturalDiff) / 60000.0;
	            			//System.out.println("timestamp: " + timeStamp + " " +  acturalDiffpercent);
	            			if (acturalDiff > 0){
	            				if (acturalDiffpercent > acturalMaxloss)
	            					acturalMaxloss = (int)acturalDiffpercent;
	            				if (acturalDiffpercent < acturalMinloss)
	            					acturalMinloss = (int)acturalDiffpercent;
	            				acturalAveloss += acturalDiffpercent;
	            				countAct++;
	            			}          			
	            		}	
	            		
	            		//if (rightPath != true)
	            		//	accuracy+=Math.abs(diff);
	            		
	            		if (rightPath || pathOverlap>tolerance) //% of tolerance to the path similarity. The higher the percentage the more strict.
	            			counter++;
	            		
	            		//System.out.println("pathOverlap:" + pathOverlap);
	            		
	            		if (pathOverlap > maxoverlap)
	            			maxoverlap = pathOverlap;
	            		if (pathOverlap < minoverlap)
	            			minoverlap = pathOverlap;
	            		overlapdiff += pathOverlap;
	            		
            		}
            		
            	}
            	rightPath=false;
            			
            }
            //System.out.println(staticTime + " counter: " + counter + "\t"  + "\t"+ accuracy + "\t" + maxloss);
            
            
            //accuracy /= 60;								// BE CAREFUL NOT TO FORGET it goes accordingly to the time range ni line 219 (60 in total)
            //aveloss = accuracy;
            int range = 15;
            
            
            aveoverlap = overlapdiff / range;
            
            
            String toPrint;
            toPrint = "source" + "\t" + "target" + "\t" + "minoverlap\t" + "aveoverlap\t" + "maxoverlap\t" + "minloss\t" + "aveloss\t" + "maxloss\t\n";
            if ((maxloss/1000)!=2147483) {				// this is the case of infinite time to reach, the node is unreachable
            	if (minloss == Integer.MAX_VALUE)
            		minloss = 0;
            	if (acturalMinloss == Integer.MAX_VALUE)
            		acturalMinloss = 0;
            	if (minoverlap == Integer.MAX_VALUE)
            		minoverlap = 0;
            	toPrint=source+"\t"+target+"\t"+counter+"\t"+minoverlap+"\t"+aveoverlap+"\t"+maxoverlap + "\t"+
            		countAve* 100 / range + "\t" +minloss+"\t"+(countAve == 0? 0: aveloss/countAve)+"\t"+maxloss+"\t"+ countAct * 100/ range + "\t" +acturalMinloss+"\t"+ (countAct == 0? 0: acturalAveloss/countAct)+"\t"+acturalMaxloss +"\n";   	
            }
            else {
            	toPrint=source+"\t"+target+"\n";
            	System.out.println(toPrint);
            }
            out.write(toPrint.getBytes());
            out.close();
//            System.out.print(toPrint);

        }
        catch (IOException io) {
            System.err.println(io.toString());
            System.err.println(io.getLocalizedMessage());
            
            System.exit(1);
        }
        catch (RuntimeException re) {
            System.err.println(re.toString());

            System.err.println(re.getLocalizedMessage());
            System.exit(1);
        }
	}
	
	public static LinkedList<Integer> stringToList (String s){		// Converts a string into a LinkedList of integers (aka path) for node manipulation
		
		LinkedList<Integer> pathList = new LinkedList<Integer>();
		StringTokenizer sT= new StringTokenizer(s," ");
				
		while (sT.hasMoreTokens()) {
			pathList.offer(Integer.parseInt(sT.nextToken()));
		}
		
		return pathList;
		
	}
	
	public static int computeOverlap(String currPath, String staticPath) {
		LinkedList<Edge> actualEdges=getEdges(stringToList(currPath));
		LinkedList<Edge> staticEdges=getEdges(stringToList(staticPath));
		int count=0;
		
		for (Edge edgeStatic:staticEdges){
			for (Edge edge:actualEdges) {
				if (edge.compare(edgeStatic)){
					count++;
					break;
				}
			}
		}
		return count*100/actualEdges.size();
		
		
		
		
	}

	private static LinkedList<Edge> getEdges(LinkedList<Integer> path) {
		LinkedList<Edge> edges = new LinkedList<Edge>();
		while (!path.isEmpty()){

			int i=path.poll();
			int j=0;
			if (path.peek()!=null)
				 j=path.peek();
				 Edge edge=new Edge(i,j);
				 edges.offer(edge);
		}
		return edges;
	}

	public static void main(String[] args) {
		
		/*times=graph.getTimes();
		path= new LinkedList<Integer>();
		
		int sou = 100880;
		int tar = 92877;
		
		
		Pair <String,Integer> p1 = computeStaticPath(sou,tar);
        String staticPath= p1.getLeft();
        String currPath = "";
        String bestPath = "";
        
        int maxDiff = Integer.MIN_VALUE;
        int diff = 0;
        int best_time = 0;
        for (int startTime = 0; startTime < times; startTime++){
        	int t = computePath(staticPath, startTime);
        	
        	tdsp_2(sou, tar, startTime);
        	int currNode = -1;
        	while (!path.isEmpty()) {
				currNode = path.poll();
				if (path.peek()!=null) {
				    currPath=currPath.concat(currNode+" ");
				}
			}
        
        	System.out.println(t+ "\t" + currNode);
        	diff = t - currNode;
        	if (diff > maxDiff){
        		bestPath = currPath;
        		maxDiff = diff;
        		best_time = startTime;
        	}
        	
        	currPath = "";
        	 	
        }
        System.out.println("MaxDiff: " + maxDiff);
        System.out.println("Best Start Time: " + best_time);
        System.out.println("Google Path: " + staticPath);
    	System.out.println("Best Path: " + bestPath);*/
    	
        
		//compare(100880,92877,1);
		
		
		for (int group = 0; group < 9; group++){
			File dir = new File(dirPath + "\\smoothed_q_" + group);
			File[] files = dir.listFiles();
			int i=0;					
	    
			for(File f:files){
				i++;
				String inFile=f.toString();
				//System.out.println("file name:" + inFile);
				int start = inFile.indexOf("smoothed_q");
				
				int a = start + 1;
				
				//System.out.println(inFile + " length: " + files.length);
				
				int source=Integer.parseInt(inFile.substring(inFile.indexOf('\\', a)+1, inFile.indexOf('-')));
				int dest=Integer.parseInt(inFile.substring(inFile.indexOf('-')+1,inFile.indexOf('.')));
				//System.out.println(source + " " + dest);
				compare(source,dest, group);
				if (i % 100 == 0)
					System.out.println("printed:"+i*100/files.length);				
								
			}
			System.out.println("congestionTime");
		}
		
		
		
		
		/*
		 * Accuray:
		 * maxloss: the max difference with static shortest path
		 * max_overhead: the percentage with static shortest path
		 * commented by Dingxiong
		 */
		//System.out.println("Counter\t Accuracy_average(min)\t accuracy_average(%)\t maxloss(sec) \t max_overhead(%)");
//		System.out.print(computeStaticPath(10003,28970).getRight().toString());
//		compare(10003,28970);
		
	}

}
